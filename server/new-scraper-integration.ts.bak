/**
 * ìƒˆë¡œìš´ ìŠ¤í¬ë˜í•‘ ì‹œìŠ¤í…œ í†µí•© (ì˜ì¡´ì„± ìµœì†Œí™”)
 * ê¸°ì¡´ ì‹œìŠ¤í…œì„ ì ì§„ì ìœ¼ë¡œ êµì²´
 */

import axios from 'axios';

interface SimpleTrade {
  id: string;
  ticker: string;
  companyName: string;
  insiderName: string;
  title: string;
  transactionDate: string;
  filingDate: string;
  transactionType: 'BUY' | 'SELL' | 'OPTION_EXERCISE' | 'GIFT' | 'OTHER';
  pricePerShare: number;
  shares: number;
  totalValue: number;
  source: 'SEC_EDGAR_API' | 'SEC_RSS_FEED' | 'OPENINSIDER';
  confidence: number;
  verified: boolean;
  createdAt: string;
}

/**
 * ê°„ë‹¨í•œ SEC EDGAR API ìŠ¤í¬ë˜í¼
 */
class SimpleEdgarScraper {
  private headers = {
    'User-Agent': 'InsiderPulse Trading Tracker info@insiderpulse.com',
    'Accept': 'application/json'
  };

  async scrapeRecentFilings(): Promise<SimpleTrade[]> {
    try {
      console.log('ğŸ›ï¸ SEC RSS í”¼ë“œì—ì„œ ëª¨ë“  ìµœì‹  Form 4 íŒŒì¼ë§ ìˆ˜ì§‘ ì¤‘...');

      // SEC RSS í”¼ë“œë¥¼ ì‚¬ìš©í•´ì„œ ëª¨ë“  Form 4 íŒŒì¼ë§ ìˆ˜ì§‘ (ëŒ€í­ í™•ëŒ€)
      const allTrades: SimpleTrade[] = [];

      // ì—¬ëŸ¬ í˜ì´ì§€ì—ì„œ ëŒ€ëŸ‰ ìˆ˜ì§‘ (ì´ 1000ê°œ Form 4 íŒŒì¼ë§)
      const pagesToCollect = [
        { start: 0, count: 100 },    // ìµœì‹  100ê°œ
        { start: 100, count: 100 },  // ë‹¤ìŒ 100ê°œ
        { start: 200, count: 100 },  // ë‹¤ìŒ 100ê°œ
        { start: 300, count: 100 },  // ë‹¤ìŒ 100ê°œ
        { start: 400, count: 100 },  // ë‹¤ìŒ 100ê°œ
        { start: 500, count: 100 },  // ë‹¤ìŒ 100ê°œ
        { start: 600, count: 100 },  // ë‹¤ìŒ 100ê°œ
        { start: 700, count: 100 },  // ë‹¤ìŒ 100ê°œ
        { start: 800, count: 100 },  // ë‹¤ìŒ 100ê°œ
        { start: 900, count: 100 }   // ë‹¤ìŒ 100ê°œ
      ];

      for (const page of pagesToCollect) {
        const rssUrl = `https://www.sec.gov/cgi-bin/browse-edgar?action=getcurrent&CIK=&type=4&company=&dateb=&owner=include&start=${page.start}&count=${page.count}&output=atom`;

        try {
          console.log(`ğŸ”„ SEC RSS í˜ì´ì§€ ìˆ˜ì§‘ ì¤‘: ${page.start}-${page.start + page.count}`);

          const response = await axios.get(rssUrl, { headers: this.headers });
          const pageTrades = await this.parseRSSFeed(response.data);
          allTrades.push(...pageTrades);

          console.log(`âœ… í˜ì´ì§€ ${page.start}-${page.start + page.count}: ${pageTrades.length}ê°œ ê±°ë˜ ìˆ˜ì§‘`);

          // SEC ì„œë²„ ë¶€í•˜ ë°©ì§€ë¥¼ ìœ„í•œ ë”œë ˆì´
          await this.delay(500);

        } catch (error) {
          console.error(`âŒ í˜ì´ì§€ ${page.start} ìˆ˜ì§‘ ì‹¤íŒ¨:`, error.message);
          continue;
        }
      }

      console.log(`âœ… ì „ì²´ SEC RSSì—ì„œ ${allTrades.length}ê°œ Form 4 ê±°ë˜ ìˆ˜ì§‘ ì™„ë£Œ`);
      return allTrades;

    } catch (error) {
      console.error('âŒ SEC RSS ëŒ€ëŸ‰ ìˆ˜ì§‘ ì‹¤íŒ¨, ë°±ì—… ë°©ì‹ ì‚¬ìš©:', error.message);

        // ë°±ì—…: ì£¼ìš” ê¸°ì—…ë“¤ë„ í¬í•¨
        const majorCIKs = [
          '0000320187', // Apple
          '0001652044', // Alphabet
          '0000789019', // Microsoft
          '0001018724', // Amazon
          '0001045810', // NVIDIA
          '0000886982', // Energy Fuels Inc (EFR)
          '0000019617', // JPMorgan Chase
          '0000732712', // Intel
          '0000051143', // IBM
          '0000066740'  // 3M
        ];

        const allTrades: SimpleTrade[] = [];

        for (const cik of majorCIKs) {
          try {
            const url = `https://data.sec.gov/submissions/CIK${cik}.json`;
            const response = await axios.get(url, { headers: this.headers });

            if (response.data && response.data.filings) {
              const trades = this.parseEdgarData(response.data, cik);
              allTrades.push(...trades);
            }

            await this.delay(100);

          } catch (error) {
            console.error(`âŒ CIK ${cik} ìˆ˜ì§‘ ì‹¤íŒ¨:`, error.message);
          }
        }

        console.log(`âœ… SEC EDGAR ë°±ì—…ì—ì„œ ${allTrades.length}ê°œ ê±°ë˜ ìˆ˜ì§‘ ì™„ë£Œ`);
        return allTrades;
      }

    } catch (error) {
      console.error('âŒ SEC EDGAR ìŠ¤í¬ë˜í•‘ ì˜¤ë¥˜:', error.message);
      return [];
    }
  }

  private parseEdgarData(data: any, cik: string): SimpleTrade[] {
    const trades: SimpleTrade[] = [];

    try {
      const recentFilings = data.filings?.recent;
      if (!recentFilings) return trades;

      // Form 4 íŒŒì¼ë§ë“¤ë§Œ ì°¾ê¸°
      const form4Indices = recentFilings.form
        .map((form: string, index: number) => form === '4' ? index : -1)
        .filter((index: number) => index !== -1)
        .slice(0, 5); // ìµœì‹  5ê°œë§Œ

      for (const index of form4Indices) {
        console.log(`âš ï¸ Form 4 íŒŒì¼ë§ ë°œê²¬: ${data.name} - ${recentFilings.filingDate[index]}`);
        console.log(`ğŸ“„ ì‹¤ì œ Form 4 XML íŒŒì‹± ì—†ì´ëŠ” ì •í™•í•œ ê±°ë˜ ë°ì´í„°ë¥¼ ì–»ì„ ìˆ˜ ì—†ìŒ`);
        console.log(`ğŸ”— íŒŒì¼ë§ ë²ˆí˜¸: ${recentFilings.accessionNumber[index]}`);

        // ì‹¤ì œ Form 4 XMLì„ íŒŒì‹±í•˜ì§€ ì•Šê³ ëŠ” ì •í™•í•œ ê±°ë˜ ì •ë³´ë¥¼ ì–»ì„ ìˆ˜ ì—†ìŒ
        // ê°€ì§œ price, shares ìƒì„±í•˜ì§€ ì•ŠìŒ
        // ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” accessionNumberë¥¼ ì‚¬ìš©í•´ XMLì„ ê°€ì ¸ì™€ì„œ íŒŒì‹±í•´ì•¼ í•¨
      }

    } catch (error) {
      console.error('âŒ EDGAR ë°ì´í„° íŒŒì‹± ì˜¤ë¥˜:', error.message);
    }

    return trades;
  }

  private async parseRSSFeed(rssData: string): Promise<SimpleTrade[]> {
    const trades: SimpleTrade[] = [];

    try {
      // RSS/Atom í”¼ë“œì—ì„œ Form 4 ì—”íŠ¸ë¦¬ë“¤ ì¶”ì¶œ
      // ê°„ë‹¨í•œ ì •ê·œì‹ìœ¼ë¡œ íŒŒì‹± (ì‹¤ì œë¡œëŠ” XML íŒŒì„œ ì‚¬ìš© ê¶Œì¥)
      const entryPattern = /<entry>(.*?)<\/entry>/gs;
      const titlePattern = /<title>(.*?)<\/title>/;
      const linkPattern = /<link[^>]*href="([^"]*)"[^>]*>/;

      const entries = rssData.match(entryPattern) || [];

      // ëª¨ë“  ì—”íŠ¸ë¦¬ ì²˜ë¦¬ (ìµœëŒ€ 200ê°œ)
      const maxEntries = Math.min(entries.length, 200);
      console.log(`ğŸ“Š RSS í”¼ë“œì—ì„œ ${maxEntries}ê°œ ì—”íŠ¸ë¦¬ ì²˜ë¦¬ ì¤‘...`);

      for (let i = 0; i < maxEntries; i++) {
        const entry = entries[i];
        const titleMatch = entry.match(titlePattern);
        const linkMatch = entry.match(linkPattern);

        if (titleMatch && linkMatch) {
          const title = titleMatch[1];
          const link = linkMatch[1];

          // Form 4 íŒŒì¼ë§ë§Œ ì²˜ë¦¬
          if (title.includes('4') && link.includes('edgar')) {
            const trade = await this.parseRSSEntry(title, link);
            if (trade) {
              trades.push(trade);
            }
          }
        }
      }

    } catch (error) {
      console.error('âŒ RSS í”¼ë“œ íŒŒì‹± ì˜¤ë¥˜:', error.message);
    }

    return trades;
  }

  private async parseRSSEntry(title: string, link: string): Promise<SimpleTrade | null> {
    try {
      console.log(`ğŸ“‹ ì‹¤ì œ Form 4 XML íŒŒì‹± ì‹œë„: ${title}`);
      console.log(`ğŸ”— ë§í¬: ${link}`);

      // RSS ë§í¬ì—ì„œ accession numberì™€ CIK ì¶”ì¶œ
      const accessionMatch = link.match(/\/(\d+-\d+-\d+)-index\.htm/);
      const cikMatch = link.match(/\/data\/(\d+)\//);

      if (!accessionMatch || !cikMatch) {
        console.log('âš ï¸ accession number ë˜ëŠ” CIK ì¶”ì¶œ ì‹¤íŒ¨');
        return null;
      }

      const accessionNumber = accessionMatch[1];
      const cik = cikMatch[1];
      const accessionNumberClean = accessionNumber.replace(/-/g, '');

      // ì—¬ëŸ¬ ê°€ëŠ¥í•œ XML íŒŒì¼ ê²½ë¡œ ì‹œë„
      const possiblePaths = [
        `https://www.sec.gov/Archives/edgar/data/${cik}/${accessionNumberClean}/xslF345X03/${accessionNumber}.xml`,
        `https://www.sec.gov/Archives/edgar/data/${cik}/${accessionNumberClean}/${accessionNumber}.txt`,
        `https://www.sec.gov/Archives/edgar/data/${cik}/${accessionNumberClean}/primary_doc.xml`,
        `https://www.sec.gov/Archives/edgar/data/${cik}/${accessionNumberClean}/doc4.xml`,
        `https://www.sec.gov/Archives/edgar/data/${cik}/${accessionNumberClean}/form4.xml`
      ];

      for (const xmlUrl of possiblePaths) {
        try {
          console.log(`ğŸ” XML URL ì‹œë„: ${xmlUrl}`);

          const xmlResponse = await axios.get(xmlUrl, {
            headers: this.headers,
            timeout: 5000,
            validateStatus: (status) => status === 200
          });

          if (xmlResponse.data && typeof xmlResponse.data === 'string' &&
              (xmlResponse.data.includes('<ownershipDocument') ||
               xmlResponse.data.includes('<XML>') ||
               xmlResponse.data.includes('FORM TYPE:') ||
               xmlResponse.data.includes('<DOCUMENT>'))) {
            console.log(`âœ… ìœ íš¨í•œ Form 4 ë¬¸ì„œ ë°œê²¬: ${xmlUrl}`);
            return this.parseForm4Content(xmlResponse.data, link, cik);
          }
        } catch (error) {
          console.log(`âŒ XML ë¡œë“œ ì‹¤íŒ¨ (${xmlUrl}): ${error.message}`);
          continue;
        }
      }

      console.log('âš ï¸ ëª¨ë“  XML ê²½ë¡œì—ì„œ ìœ íš¨í•œ Form 4 ë¬¸ì„œë¥¼ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤');
      return null;

    } catch (error) {
      console.error('âŒ Form 4 XML íŒŒì‹± ì‹¤íŒ¨:', error.message);
      // XML íŒŒì‹± ì‹¤íŒ¨ì‹œì—ë„ null ë°˜í™˜ (ê°€ì§œ ë°ì´í„° ìƒì„± ì•ˆí•¨)
      return null;
    }
  }

  private parseForm4Content(docData: string, originalLink: string, cik: string): SimpleTrade | null {
    try {
      console.log('ğŸ” Form 4 ë¬¸ì„œ ë‚´ìš© íŒŒì‹± ì‹œì‘...');

      // SGML/XML í˜•ì‹ê³¼ ì¼ë°˜ í…ìŠ¤íŠ¸ í˜•ì‹ ëª¨ë‘ ì²˜ë¦¬
      let xmlContent = docData;

      // SGML ë¬¸ì„œì—ì„œ XML ë¶€ë¶„ ì¶”ì¶œ
      if (docData.includes('<DOCUMENT>')) {
        const xmlMatch = docData.match(/<XML>([\s\S]*?)<\/XML>/i);
        if (xmlMatch) {
          xmlContent = xmlMatch[1];
        }
      }

      // ownershipDocumentì—ì„œ ë°ì´í„° ì¶”ì¶œ
      const issuerName = this.extractTagContent(xmlContent, 'issuerName') ||
                        this.extractTagContent(xmlContent, 'companyName') || 'Unknown Company';
      const issuerCik = this.extractTagContent(xmlContent, 'issuerCik') || cik;

      // ì‹ ê³ ì ì •ë³´
      const rptOwnerName = this.extractTagContent(xmlContent, 'rptOwnerName') ||
                          this.extractTagContent(xmlContent, 'ownerName') || 'Unknown Insider';

      // ê±°ë˜ ì •ë³´ - ê°€ì¥ ìµœê·¼ ê±°ë˜ ì¶”ì¶œ (nonDerivativeTable ë˜ëŠ” derivativeTable)
      const transactionDate = this.extractTagContent(xmlContent, 'transactionDate') ||
                             this.extractTransactionDate(xmlContent);
      const transactionCode = this.extractTagContent(xmlContent, 'transactionCode') ||
                             this.extractTransactionCode(xmlContent);
      const transactionShares = this.extractTagContent(xmlContent, 'transactionShares') ||
                               this.extractTagContent(xmlContent, 'sharesOwnedFollowingTransaction') ||
                               this.extractSharesAmount(xmlContent);
      const transactionPricePerShare = this.extractTagContent(xmlContent, 'transactionPricePerShare') ||
                                      this.extractPricePerShare(xmlContent);

      // ê±°ë˜ íƒ€ì… ë§¤í•‘
      const transactionType = this.mapTransactionCode(transactionCode);

      // ìˆ˜ì¹˜ ê³„ì‚°
      const shares = this.parseNumber(transactionShares) || 0;
      const pricePerShare = this.parseNumber(transactionPricePerShare) || 0;
      const totalValue = shares * pricePerShare;

      // í•„ìˆ˜ ë°ì´í„° ê²€ì¦ - ì‹¤ì œ ê±°ë˜ê°€ ìˆëŠ” ê²½ìš°ë§Œ ë°˜í™˜
      if (!issuerName || !rptOwnerName || !transactionDate || shares === 0) {
        console.log(`âš ï¸ í•„ìˆ˜ ê±°ë˜ ë°ì´í„° ëˆ„ë½: ${issuerName}, ${rptOwnerName}, ${transactionDate}, ${shares}`);
        return null;
      }

      // ê±°ë˜ ê°€ê²©ì´ ë„ˆë¬´ ë‚®ê±°ë‚˜ ë†’ìœ¼ë©´ ì˜ì‹¬ìŠ¤ëŸ¬ìš´ ë°ì´í„°ë¡œ ê°„ì£¼
      if (pricePerShare > 0 && (pricePerShare < 0.01 || pricePerShare > 10000)) {
        console.log(`âš ï¸ ì˜ì‹¬ìŠ¤ëŸ¬ìš´ ê°€ê²© ë°ì´í„°: $${pricePerShare}`);
      }

      // í‹°ì»¤ ì¶”ì¶œ
      const ticker = this.getTickerByCIKFromXML(issuerCik) ||
                    this.extractTickerFromName(issuerName);

      const trade: SimpleTrade = {
        id: `sec_real_${issuerCik}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        ticker,
        companyName: issuerName,
        insiderName: rptOwnerName,
        title: this.extractTagContent(xmlContent, 'officerTitle') || 'Insider',
        transactionDate: this.formatDate(transactionDate),
        filingDate: new Date().toISOString().split('T')[0],
        transactionType,
        pricePerShare,
        shares,
        totalValue,
        source: 'SEC_EDGAR_API' as const,
        confidence: 95, // ì‹¤ì œ SEC ë°ì´í„°ì´ë¯€ë¡œ ë†’ì€ ì‹ ë¢°ë„
        verified: true, // SEC ê³µì‹ ë°ì´í„°ëŠ” ê²€ì¦ë¨
        createdAt: new Date().toISOString()
      };

      console.log(`âœ… ì‹¤ì œ ê±°ë˜ ë°ì´í„° íŒŒì‹± ì™„ë£Œ: ${ticker} - ${rptOwnerName} - $${totalValue.toLocaleString()}`);
      return trade;

    } catch (error) {
      console.error('âŒ Form 4 ë¬¸ì„œ íŒŒì‹± ì¤‘ ì˜¤ë¥˜:', error.message);
      return null;
    }
  }

  private extractTagContent(xml: string, tagName: string): string | null {
    // XML íƒœê·¸ì—ì„œ ë‚´ìš© ì¶”ì¶œ
    const patterns = [
      `<${tagName}[^>]*>([^<]+)</${tagName}>`,
      `<${tagName}>([^<]+)</${tagName}>`,
      `<${tagName}[^>]*>\\s*<value>([^<]+)</value>`,
      `<${tagName}[^>]*>\\s*([^<\\s]+)\\s*<`
    ];

    for (const pattern of patterns) {
      const regex = new RegExp(pattern, 'i');
      const match = xml.match(regex);
      if (match && match[1] && match[1].trim()) {
        return match[1].trim();
      }
    }

    return null;
  }

  private extractTransactionDate(xml: string): string | null {
    // ë‹¤ì–‘í•œ ê±°ë˜ì¼ íŒ¨í„´ ì‹œë„
    const patterns = [
      /<transactionDate>\s*<value>([^<]+)<\/value>/i,
      /<transactionDate>([^<]+)<\/transactionDate>/i,
      /<date>([^<]+)<\/date>/i,
      /TRANSACTION DATE:\s*(\d{2}\/\d{2}\/\d{4})/i,
      /DATE:\s*(\d{4}-\d{2}-\d{2})/i
    ];

    for (const pattern of patterns) {
      const match = xml.match(pattern);
      if (match && match[1]) {
        return match[1].trim();
      }
    }

    return null;
  }

  private extractTransactionCode(xml: string): string | null {
    // ê±°ë˜ ì½”ë“œ ì¶”ì¶œ
    const patterns = [
      /<transactionCode>([^<]+)<\/transactionCode>/i,
      /<code>([^<]+)<\/code>/i,
      /TRANSACTION CODE:\s*([A-Z])/i
    ];

    for (const pattern of patterns) {
      const match = xml.match(pattern);
      if (match && match[1]) {
        return match[1].trim();
      }
    }

    return null;
  }

  private extractSharesAmount(xml: string): string | null {
    // ì£¼ì‹ ìˆ˜ëŸ‰ ì¶”ì¶œ
    const patterns = [
      /<transactionShares>\s*<value>([^<]+)<\/value>/i,
      /<transactionShares>([^<]+)<\/transactionShares>/i,
      /<sharesOwnedFollowingTransaction>\s*<value>([^<]+)<\/value>/i,
      /<amount>([^<]+)<\/amount>/i,
      /SHARES:\s*([\d,]+)/i
    ];

    for (const pattern of patterns) {
      const match = xml.match(pattern);
      if (match && match[1]) {
        return match[1].trim();
      }
    }

    return null;
  }

  private extractPricePerShare(xml: string): string | null {
    // ì£¼ë‹¹ ê°€ê²© ì¶”ì¶œ
    const patterns = [
      /<transactionPricePerShare>\s*<value>([^<]+)<\/value>/i,
      /<transactionPricePerShare>([^<]+)<\/transactionPricePerShare>/i,
      /<pricePerShare>([^<]+)<\/pricePerShare>/i,
      /PRICE PER SHARE:\s*\$?([\d,.]+)/i
    ];

    for (const pattern of patterns) {
      const match = xml.match(pattern);
      if (match && match[1]) {
        return match[1].trim();
      }
    }

    return null;
  }

  private parseNumber(value: string | null): number {
    if (!value) return 0;
    // ìˆ«ìê°€ ì•„ë‹Œ ë¬¸ì ì œê±°í•˜ê³  íŒŒì‹±
    const cleaned = value.replace(/[,$]/g, '');
    const parsed = parseFloat(cleaned);
    return isNaN(parsed) ? 0 : parsed;
  }

  private parseForm4XML(xmlData: string, originalLink: string): SimpleTrade | null {
    try {
      console.log('ğŸ” Form 4 XML ì‹¤ì œ íŒŒì‹± ì‹œì‘...');

      // ê¸°ë³¸ ì •ë³´ ì¶”ì¶œ
      const issuerName = this.extractXMLValue(xmlData, 'issuerName') ||
                        this.extractXMLValue(xmlData, 'companyName') || 'Unknown Company';
      const issuerCik = this.extractXMLValue(xmlData, 'issuerCik') ||
                       this.extractXMLValue(xmlData, 'cik') || '';

      // ì‹ ê³ ì ì •ë³´
      const rptOwnerName = this.extractXMLValue(xmlData, 'rptOwnerName') ||
                          this.extractXMLValue(xmlData, 'ownerName') || 'Unknown Insider';
      const ownerTitle = this.extractXMLValue(xmlData, 'officerTitle') ||
                        this.extractXMLValue(xmlData, 'title') || 'Insider';

      // ê±°ë˜ ì •ë³´ - ê°€ì¥ ìµœê·¼ ê±°ë˜ ì¶”ì¶œ
      const transactionDate = this.extractXMLValue(xmlData, 'transactionDate') ||
                             this.extractXMLValue(xmlData, 'executionDate') || '';
      const transactionCode = this.extractXMLValue(xmlData, 'transactionCode') || '';
      const transactionShares = this.extractXMLValue(xmlData, 'transactionShares') ||
                               this.extractXMLValue(xmlData, 'shares') || '0';
      const transactionPricePerShare = this.extractXMLValue(xmlData, 'transactionPricePerShare') ||
                                      this.extractXMLValue(xmlData, 'pricePerShare') || '0';

      // ê±°ë˜ íƒ€ì… ë§¤í•‘
      const transactionType = this.mapTransactionCode(transactionCode);

      // ìˆ˜ì¹˜ ê³„ì‚°
      const shares = parseFloat(transactionShares) || 0;
      const pricePerShare = parseFloat(transactionPricePerShare) || 0;
      const totalValue = shares * pricePerShare;

      // í•„ìˆ˜ ë°ì´í„°ê°€ ì—†ìœ¼ë©´ null ë°˜í™˜ (ê°€ì§œ ë°ì´í„° ìƒì„± ì•ˆí•¨)
      if (!issuerName || !rptOwnerName || !transactionDate || shares === 0) {
        console.log('âš ï¸ í•„ìˆ˜ ê±°ë˜ ë°ì´í„° ëˆ„ë½, null ë°˜í™˜');
        return null;
      }

      // í‹°ì»¤ ì¶”ì¶œ
      const ticker = this.getTickerByCIKFromXML(issuerCik) ||
                    this.extractTickerFromName(issuerName);

      const trade: SimpleTrade = {
        id: `sec_real_${issuerCik}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        ticker,
        companyName: issuerName,
        insiderName: rptOwnerName,
        title: ownerTitle,
        transactionDate: this.formatDate(transactionDate),
        filingDate: new Date().toISOString().split('T')[0],
        transactionType,
        pricePerShare,
        shares,
        totalValue,
        source: 'SEC_EDGAR_API' as const,
        confidence: 95, // ì‹¤ì œ SEC ë°ì´í„°ì´ë¯€ë¡œ ë†’ì€ ì‹ ë¢°ë„
        verified: true, // SEC ê³µì‹ ë°ì´í„°ëŠ” ê²€ì¦ë¨
        createdAt: new Date().toISOString()
      };

      console.log(`âœ… ì‹¤ì œ ê±°ë˜ ë°ì´í„° íŒŒì‹± ì™„ë£Œ: ${ticker} - ${rptOwnerName} - $${totalValue.toLocaleString()}`);
      return trade;

    } catch (error) {
      console.error('âŒ Form 4 XML íŒŒì‹± ì¤‘ ì˜¤ë¥˜:', error.message);
      return null;
    }
  }

  private extractXMLValue(xml: string, tagName: string): string | null {
    // ë‹¤ì–‘í•œ XML íƒœê·¸ íŒ¨í„´ ì‹œë„
    const patterns = [
      `<${tagName}[^>]*>([^<]+)</${tagName}>`,
      `<${tagName}>([^<]+)</${tagName}>`,
      `<${tagName}[^>]*>\\s*<value>([^<]+)</value>`,
      `<${tagName}[^>]*>\\s*([^<\\s]+)\\s*<`,
    ];

    for (const pattern of patterns) {
      const regex = new RegExp(pattern, 'i');
      const match = xml.match(regex);
      if (match && match[1]) {
        return match[1].trim();
      }
    }

    return null;
  }

  private mapTransactionCode(code: string): SimpleTrade['transactionType'] {
    const codeMap: { [key: string]: SimpleTrade['transactionType'] } = {
      'P': 'BUY',
      'S': 'SELL',
      'A': 'BUY',
      'D': 'SELL',
      'M': 'OPTION_EXERCISE',
      'X': 'OPTION_EXERCISE',
      'G': 'GIFT',
      'J': 'OTHER',
      'K': 'OTHER',
      'L': 'OTHER',
      'W': 'OTHER',
      'Z': 'OTHER'
    };

    return codeMap[code?.toUpperCase()] || 'OTHER';
  }

  private getTickerByCIKFromXML(cik: string): string | null {
    const cikToTicker: { [key: string]: string } = {
      // ëŒ€í˜•ì£¼
      '320187': 'AAPL',
      '1652044': 'GOOGL',
      '789019': 'MSFT',
      '1018724': 'AMZN',
      '1045810': 'NVDA',
      '1326801': 'META',
      '1318605': 'TSLA',
      '19617': 'JPM',
      '732712': 'INTC',
      '51143': 'IBM',
      '66740': 'MMM',

      // ì¤‘ì†Œí˜•ì£¼ ë° ê¸°íƒ€ ì£¼ì‹ë“¤
      '886982': 'EFR',     // Energy Fuels Inc
      '1571996': 'DELL',   // Dell Technologies
      '1046102': 'RBI',    // RB Global Inc
      '1492422': 'APLS',   // Apellis Pharmaceuticals
      '1604821': 'NTRA',   // Natera Inc
      '1562088': 'DUOL',   // Duolingo Inc
      '1818874': 'SOFI',   // SoFi Technologies
      '1356090': 'PGEN',   // Precigen Inc
      '1861107': 'CBLL',   // Ceribell Inc
      '1916099': 'DCRB',   // Diameter Credit Co
      '1579877': 'OUT',    // OUTFRONT Media

      // ì¶”ê°€ ì¤‘ì†Œí˜•ì£¼ë“¤
      '1672619': 'ELVN',   // Enliven Therapeutics
      '1376960': 'OBIA',   // Obia Pharma
      '1350653': 'ATEC',   // Alphatec Holdings
      '1786205': 'ACLX',   // Arcellx Inc
      '1582313': 'XENE',   // Xenon Pharmaceuticals
      '728618': 'MET',     // MetLife Inc
      '1099219': 'MET',    // MetLife entities
      '1650164': 'RARE',   // Ultragenyx Pharmaceutical
      '1467858': 'CRM',    // Salesforce
      '1551152': 'SNOW',   // Snowflake
      '1677576': 'CVNA',   // Carvana
      '1090872': 'ANET',   // Arista Networks
      '1378946': 'LRN',    // Stride Inc
      '1835632': 'CCCS',   // CCC Intelligent Solutions
      '1770450': 'HBM',    // Hudbay Minerals
      '1824149': 'SITM',   // SiTime Corp
      '1828536': 'OKLO',   // Oklo Inc
      '1829227': 'GTLB',   // GitLab Inc
      '1543151': 'MGNI',   // Magnite Inc
      '1756111': 'WSM',    // Williams-Sonoma
      '1604778': 'UPWK',   // Upwork Inc
      '1633917': 'NGS',    // Natural Gas Services
      '1463101': 'RNGR',   // Ranger Energy Services
      '1011006': 'PI',     // Impinj Inc
      '1846016': 'WRBY',   // Warby Parker
      '1040971': 'KRC',    // Kilroy Realty Corp
      '1652879': 'IDR',    // Idaho Strategic Resources
      '1828806': 'CART',   // Maplebear Inc
      '1829126': 'CRWV',   // Crown Electrokinetics
      '354950': 'HD',      // Home Depot
      '40545': 'GE',       // General Electric
      '72971': 'WFC',      // Wells Fargo
      '78003': 'PFE'       // Pfizer
    };

    const cleanCik = cik?.replace(/^0+/, ''); // ì•ì˜ 0 ì œê±°
    return cikToTicker[cleanCik] || null;
  }

  private extractTickerFromName(companyName: string): string {
    const name = companyName.toLowerCase();

    // ëŒ€í˜•ì£¼
    if (name.includes('apple')) return 'AAPL';
    if (name.includes('microsoft')) return 'MSFT';
    if (name.includes('amazon')) return 'AMZN';
    if (name.includes('nvidia')) return 'NVDA';
    if (name.includes('alphabet') || name.includes('google')) return 'GOOGL';
    if (name.includes('meta') || name.includes('facebook')) return 'META';
    if (name.includes('tesla')) return 'TSLA';

    // ì¤‘ì†Œí˜•ì£¼ ë° íŠ¹ìˆ˜í•œ ê²½ìš°ë“¤
    if (name.includes('energy fuels')) return 'EFR';
    if (name.includes('dell technologies')) return 'DELL';
    if (name.includes('rb global')) return 'RBI';
    if (name.includes('apellis pharmaceuticals')) return 'APLS';
    if (name.includes('natera')) return 'NTRA';
    if (name.includes('duolingo')) return 'DUOL';
    if (name.includes('sofi technologies')) return 'SOFI';
    if (name.includes('precigen')) return 'PGEN';
    if (name.includes('ceribell')) return 'CBLL';
    if (name.includes('diameter credit')) return 'DCRB';
    if (name.includes('outfront media')) return 'OUT';
    if (name.includes('enliven therapeutics')) return 'ELVN';
    if (name.includes('alphatec')) return 'ATEC';
    if (name.includes('arcellx')) return 'ACLX';
    if (name.includes('xenon pharmaceuticals')) return 'XENE';
    if (name.includes('metlife')) return 'MET';
    if (name.includes('ultragenyx')) return 'RARE';
    if (name.includes('salesforce')) return 'CRM';
    if (name.includes('snowflake')) return 'SNOW';
    if (name.includes('carvana')) return 'CVNA';
    if (name.includes('arista networks')) return 'ANET';
    if (name.includes('stride')) return 'LRN';
    if (name.includes('ccc intelligent')) return 'CCCS';
    if (name.includes('hudbay minerals')) return 'HBM';
    if (name.includes('sitime')) return 'SITM';
    if (name.includes('oklo')) return 'OKLO';
    if (name.includes('gitlab')) return 'GTLB';
    if (name.includes('magnite')) return 'MGNI';
    if (name.includes('williams-sonoma')) return 'WSM';
    if (name.includes('upwork')) return 'UPWK';
    if (name.includes('natural gas services')) return 'NGS';
    if (name.includes('ranger energy')) return 'RNGR';
    if (name.includes('impinj')) return 'PI';
    if (name.includes('warby parker')) return 'WRBY';
    if (name.includes('kilroy realty')) return 'KRC';
    if (name.includes('idaho strategic')) return 'IDR';
    if (name.includes('maplebear')) return 'CART';
    if (name.includes('crown electrokinetics')) return 'CRWV';
    if (name.includes('home depot')) return 'HD';
    if (name.includes('general electric')) return 'GE';
    if (name.includes('wells fargo')) return 'WFC';
    if (name.includes('pfizer')) return 'PFE';

    // ê¸°ë³¸ê°’: íšŒì‚¬ëª…ì—ì„œ ì•½ì–´ ìƒì„± (ì¤‘ì†Œí˜•ì£¼ìš©)
    const words = companyName.split(' ').filter(word =>
      word.length > 2 && !['inc', 'corp', 'llc', 'ltd', 'co'].includes(word.toLowerCase())
    );
    if (words.length >= 2) {
      return words.slice(0, 2).map(word => word.charAt(0).toUpperCase()).join('') + 'XX';
    }
    return words.slice(0, 1).map(word => word.substring(0, 3).toUpperCase()).join('') + 'X';
  }

  private formatDate(dateStr: string): string {
    try {
      // ë‹¤ì–‘í•œ ë‚ ì§œ í˜•ì‹ ì²˜ë¦¬
      if (dateStr.includes('-')) {
        return dateStr.split('T')[0]; // ISO í˜•ì‹
      }

      // MMDDYYYY í˜•ì‹ ì²˜ë¦¬
      if (dateStr.length === 8) {
        const month = dateStr.substr(0, 2);
        const day = dateStr.substr(2, 2);
        const year = dateStr.substr(4, 4);
        return `${year}-${month}-${day}`;
      }

      return new Date().toISOString().split('T')[0];
    } catch {
      return new Date().toISOString().split('T')[0];
    }
  }

  private async getTickerFromCompanyName(companyName: string): Promise<string> {
    // ê°„ë‹¨í•œ íšŒì‚¬ëª…-í‹°ì»¤ ë§¤í•‘ (ì‹¤ì œë¡œëŠ” API ì¡°íšŒ í•„ìš”)
    const commonMappings: { [key: string]: string } = {
      'Apple': 'AAPL',
      'Microsoft': 'MSFT',
      'Amazon': 'AMZN',
      'Alphabet': 'GOOGL',
      'Google': 'GOOGL',
      'Tesla': 'TSLA',
      'Meta': 'META',
      'Facebook': 'META',
      'NVIDIA': 'NVDA',
      'Energy Fuels': 'EFR',
      'Intel': 'INTC',
      'IBM': 'IBM',
      'JPMorgan': 'JPM'
    };

    for (const [company, ticker] of Object.entries(commonMappings)) {
      if (companyName.toLowerCase().includes(company.toLowerCase())) {
        return ticker;
      }
    }

    // ê¸°ë³¸ê°’: íšŒì‚¬ëª…ì—ì„œ ì²« ê¸€ìë“¤ ì¶”ì¶œ
    const words = companyName.split(' ').filter(word => word.length > 2);
    return words.slice(0, 3).map(word => word.charAt(0).toUpperCase()).join('') + 'X';
  }

  private getTickerByCIK(cik: string): string {
    const cikToTicker: { [key: string]: string } = {
      '0000320187': 'AAPL',
      '0001652044': 'GOOGL',
      '0000789019': 'MSFT',
      '0001018724': 'AMZN',
      '0001045810': 'NVDA',
      '0000886982': 'EFR',
      '0000019617': 'JPM',
      '0000732712': 'INTC',
      '0000051143': 'IBM',
      '0000066740': 'MMM'
    };
    return cikToTicker[cik] || 'UNKNOWN';
  }

  private generateId(cik: string, index: number): string {
    return `edgar_${cik}_${index}_${Date.now()}`;
  }

  private delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}

/**
 * ê°„ë‹¨í•œ OpenInsider ìŠ¤í¬ë˜í¼ (HTML íŒŒì‹± ì—†ì´)
 */
class SimpleOpenInsiderScraper {
  async scrapeLatestTrades(): Promise<SimpleTrade[]> {
    console.log('âš ï¸ OpenInsider ì‹¤ì œ ìŠ¤í¬ë˜í•‘ ë¹„í™œì„±í™”ë¨ - ì‹œë®¬ë ˆì´ì…˜ ë°ì´í„° ì‚¬ìš© ê¸ˆì§€');
    console.log('ğŸ’¡ ì‹¤ì œ OpenInsider ë°ì´í„°ë§Œ í•„ìš”í•  ë•Œ cheerio ì˜ì¡´ì„± ì¶”ê°€ í›„ êµ¬í˜„ ì˜ˆì •');

    // ì‹œë®¬ë ˆì´ì…˜ ë°ì´í„° ì™„ì „ ì œê±° - ë¹ˆ ë°°ì—´ ë°˜í™˜
    return [];
  }
}

/**
 * í†µí•© ìŠ¤í¬ë˜í•‘ ê´€ë¦¬ì
 */
export class NewScrapingManager {
  private trades: Map<string, SimpleTrade> = new Map();
  private edgarScraper = new SimpleEdgarScraper();
  private openInsiderScraper = new SimpleOpenInsiderScraper();
  private isRunning = false;

  constructor() {
    console.log('ğŸš€ ìƒˆë¡œìš´ ìŠ¤í¬ë˜í•‘ ê´€ë¦¬ì ì´ˆê¸°í™”ë¨');
  }

  /**
   * ì „ì²´ ë°ì´í„° ìˆ˜ì§‘ ì‹¤í–‰
   */
  async executeFullCollection(): Promise<SimpleTrade[]> {
    if (this.isRunning) {
      console.log('âš ï¸ ìŠ¤í¬ë˜í•‘ì´ ì´ë¯¸ ì‹¤í–‰ ì¤‘ì…ë‹ˆë‹¤');
      return Array.from(this.trades.values());
    }

    this.isRunning = true;
    console.log('ğŸ”„ ìƒˆë¡œìš´ í†µí•© ìŠ¤í¬ë˜í•‘ ì‹œì‘...');

    try {
      const startTime = Date.now();

      // ë³‘ë ¬ë¡œ ë°ì´í„° ìˆ˜ì§‘
      const [edgarTrades, openInsiderTrades] = await Promise.allSettled([
        this.edgarScraper.scrapeRecentFilings(),
        this.openInsiderScraper.scrapeLatestTrades()
      ]);

      const allTrades: SimpleTrade[] = [];

      if (edgarTrades.status === 'fulfilled') {
        allTrades.push(...edgarTrades.value);
      }

      if (openInsiderTrades.status === 'fulfilled') {
        allTrades.push(...openInsiderTrades.value);
      }

      // ì¤‘ë³µ ì œê±° ë° ì €ì¥
      const uniqueTrades = this.removeDuplicates(allTrades);
      uniqueTrades.forEach(trade => {
        this.trades.set(trade.id, trade);
      });

      const endTime = Date.now();
      console.log(`âœ… ìƒˆë¡œìš´ ìŠ¤í¬ë˜í•‘ ì™„ë£Œ!`);
      console.log(`ğŸ“Š ê²°ê³¼: ${uniqueTrades.length}ê°œ ê³ í’ˆì§ˆ ê±°ë˜ ë°ì´í„°`);
      console.log(`â±ï¸ ì†Œìš” ì‹œê°„: ${((endTime - startTime) / 1000).toFixed(1)}ì´ˆ`);

      return uniqueTrades;

    } catch (error) {
      console.error('âŒ í†µí•© ìŠ¤í¬ë˜í•‘ ì˜¤ë¥˜:', error.message);
      return [];
    } finally {
      this.isRunning = false;
    }
  }

  /**
   * ì¤‘ë³µ ì œê±°
   */
  private removeDuplicates(trades: SimpleTrade[]): SimpleTrade[] {
    const uniqueMap = new Map<string, SimpleTrade>();

    for (const trade of trades) {
      const key = `${trade.ticker}_${trade.insiderName}_${trade.transactionDate}_${trade.totalValue.toFixed(0)}`;

      if (!uniqueMap.has(key)) {
        uniqueMap.set(key, trade);
      } else {
        // ë” ì‹ ë¢°í•  ìˆ˜ ìˆëŠ” ì†ŒìŠ¤ ìš°ì„ 
        const existing = uniqueMap.get(key)!;
        if (this.getSourcePriority(trade.source) > this.getSourcePriority(existing.source)) {
          uniqueMap.set(key, trade);
        }
      }
    }

    return Array.from(uniqueMap.values());
  }

  private getSourcePriority(source: string): number {
    switch (source) {
      case 'SEC_EDGAR_API': return 3;
      case 'SEC_RSS_FEED': return 2;
      case 'OPENINSIDER': return 1;
      default: return 0;
    }
  }

  /**
   * ì €ì¥ëœ ê±°ë˜ ë°ì´í„° ë°˜í™˜
   */
  getAllTrades(): SimpleTrade[] {
    return Array.from(this.trades.values())
      .sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());
  }

  /**
   * í•„í„°ë§ëœ ê±°ë˜ ë°ì´í„° ë°˜í™˜
   */
  getFilteredTrades(filters: {
    ticker?: string;
    minValue?: number;
    maxValue?: number;
    transactionType?: string;
    minConfidence?: number;
    verifiedOnly?: boolean;
  }): SimpleTrade[] {
    let trades = this.getAllTrades();

    if (filters.ticker) {
      trades = trades.filter(t => t.ticker === filters.ticker.toUpperCase());
    }

    if (filters.minValue) {
      trades = trades.filter(t => t.totalValue >= filters.minValue!);
    }

    if (filters.maxValue) {
      trades = trades.filter(t => t.totalValue <= filters.maxValue!);
    }

    if (filters.transactionType) {
      trades = trades.filter(t => t.transactionType === filters.transactionType);
    }

    if (filters.minConfidence) {
      trades = trades.filter(t => t.confidence >= filters.minConfidence!);
    }

    if (filters.verifiedOnly) {
      trades = trades.filter(t => t.verified);
    }

    return trades;
  }

  /**
   * í†µê³„ ì •ë³´ ë°˜í™˜
   */
  getStatistics(): any {
    const trades = this.getAllTrades();

    return {
      totalTrades: trades.length,
      verifiedTrades: trades.filter(t => t.verified).length,
      averageConfidence: trades.reduce((sum, t) => sum + t.confidence, 0) / trades.length || 0,
      sourceBreakdown: {
        edgar: trades.filter(t => t.source === 'SEC_EDGAR_API').length,
        rss: trades.filter(t => t.source === 'SEC_RSS_FEED').length,
        openinsider: trades.filter(t => t.source === 'OPENINSIDER').length
      },
      transactionTypeBreakdown: {
        buy: trades.filter(t => t.transactionType === 'BUY').length,
        sell: trades.filter(t => t.transactionType === 'SELL').length,
        optionExercise: trades.filter(t => t.transactionType === 'OPTION_EXERCISE').length,
        gift: trades.filter(t => t.transactionType === 'GIFT').length,
        other: trades.filter(t => t.transactionType === 'OTHER').length
      },
      totalValue: trades.reduce((sum, t) => sum + t.totalValue, 0),
      averageValue: trades.reduce((sum, t) => sum + t.totalValue, 0) / trades.length || 0,
      lastUpdated: new Date().toISOString()
    };
  }

  /**
   * ìë™ ìŠ¤ì¼€ì¤„ë§ ì‹œì‘ (ê°„ë‹¨í•œ setInterval ì‚¬ìš©)
   */
  startAutoCollection(intervalMinutes: number = 10): void {
    console.log(`â° ìë™ ë°ì´í„° ìˆ˜ì§‘ ì‹œì‘ (${intervalMinutes}ë¶„ë§ˆë‹¤)`);

    // ì¦‰ì‹œ í•œ ë²ˆ ì‹¤í–‰
    this.executeFullCollection();

    // ì£¼ê¸°ì  ì‹¤í–‰
    setInterval(async () => {
      console.log('ğŸ”„ ìŠ¤ì¼€ì¤„ëœ ë°ì´í„° ìˆ˜ì§‘ ì‹¤í–‰...');
      await this.executeFullCollection();
    }, intervalMinutes * 60 * 1000);
  }
}

// Export singleton instance
export const newScrapingManager = new NewScrapingManager();